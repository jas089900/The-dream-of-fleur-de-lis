#############################
# Marching Cubes完整实现
#############################

class MarchingCubes:
    """完整的移动立方体算法实现"""

    # 边连接表
    edge_table = [
        0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
        0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
        0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
        0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
        0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
        0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
        0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
        0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
        0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
        0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
        0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
        0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
        0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
        0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
        0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
        0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
        0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
        0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
        0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
        0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
        0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
    ]

    tri_table = [
        [-1],
        [0, 8, 3, -1], [0, 1, 9, -1], [1, 8, 3, 9, 8, 1, -1], [1, 2, 10, -1], [0, 8, 3, 1, 2, 10, -1],
        [9, 2, 10, 0, 2, 9, -1], [1, 8, 3, 9, 2, 10, 2, 8, 9, -1], [3, 11, 2, -1],
        [0, 11, 2, 8, 11, 0, -1], [1, 9, 0, 2, 3, 11, -1], [1, 11, 2, 1, 9, 11, 9, 8, 11, -1],
        [3, 10, 1, 3, 11, 10, -1], [0, 10, 1, 0, 8, 10, 8, 11, 10, -1], [3, 9, 0, 3, 11, 9, 11, 10, 9, -1],
        [9, 10, 8, 10, 11, 8, -1], [4, 7, 8, -1], [4, 3, 0, 7, 3, 4, -1], [0, 9, 1, 8, 4, 7, -1],
        [4, 1, 9, 4, 7, 1, 7, 3, 1, -1], [1, 2, 10, 8, 4, 7, -1], [3, 4, 7, 3, 0, 4, 0, 2, 4, 0, 10, 2, -1],
        [9, 2, 10, 9, 0, 2, 8, 4, 7, -1], [2, 10, 9, 2, 9, 7, 7, 9, 4, 2, 7, 3, -1],
        [8, 4, 7, 3, 11, 2, -1], [11, 4, 7, 11, 2, 4, 2, 0, 4, -1], [9, 1, 0, 8, 4, 7, 2, 3, 11, -1],
        [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1], [3, 10, 1, 3, 11, 10, 7, 8, 4, -1],
        [1, 10, 11, 1, 11, 4, 4, 11, 7, 1, 4, 0, -1], [8, 4, 7, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1],
        [4, 7, 8, 11, 10, 9, 11, 9, 4, 11, 4, 10, -1], [9, 5, 4, -1], [9, 5, 4, 0, 3, 8, -1],
        [0, 5, 4, 1, 5, 0, -1], [8, 5, 4, 8, 3, 5, 3, 1, 5, -1], [1, 2, 10, 9, 5, 4, -1],
        [3, 8, 0, 1, 2, 10, 4, 9, 5, -1], [5, 2, 10, 5, 4, 2, 4, 0, 2, -1],
        [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1], [9, 5, 4, 2, 3, 11, -1],
        [0, 11, 2, 0, 8, 11, 4, 9, 5, -1], [0, 5, 4, 0, 1, 5, 2, 3, 11, -1],
        [2, 1, 5, 2, 5, 8, 8, 5, 4, 2, 8, 11, -1], [10, 3, 11, 10, 1, 3, 9, 5, 4, -1],
        [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1], [5, 4, 0, 5, 0, 11, 11, 0, 3, 5, 11, 10, -1],
        [5, 4, 8, 5, 8, 10, 10, 8, 11, -1], [9, 7, 8, 9, 5, 7, -1], [9, 3, 0, 9, 5, 3, 5, 7, 3, -1],
        [0, 7, 8, 0, 1, 7, 1, 5, 7, -1], [1, 5, 7, 3, 1, 7, -1], [9, 7, 8, 9, 5, 7, 10, 1, 2, -1],
        [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1], [8, 0, 2, 8, 2, 5, 5, 2, 10, 8, 5, 7, -1],
        [2, 10, 5, 2, 5, 3, 3, 5, 7, -1], [7, 9, 5, 7, 8, 9, 3, 11, 2, -1],
        [9, 5, 7, 9, 7, 2, 2, 7, 11, 9, 2, 0, -1], [2, 3, 11, 0, 1, 8, 1, 5, 8, 5, 7, 8, -1],
        [11, 2, 1, 11, 1, 7, 7, 1, 5, -1], [9, 5, 4, 10, 1, 3, 10, 3, 11, -1],
        [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1], [5, 4, 0, 5, 0, 11, 11, 0, 3, 5, 11, 10, -1],
        [5, 4, 8, 5, 8, 10, 10, 8, 11, -1], [9, 5, 7, 8, 9, 7, -1], [9, 5, 7, 8, 9, 7, -1],
        [0, 5, 7, 0, 1, 5, 1, 3, 5, 3, 7, 5, -1], [1, 5, 3, 3, 5, 7, -1],
        [9, 5, 7, 8, 9, 7, 10, 1, 2, -1], [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1],
        [8, 0, 2, 8, 2, 5, 5, 2, 10, 8, 5, 7, -1], [2, 10, 5, 2, 5, 3, 3, 5, 7, -1],
        [7, 9, 5, 7, 8, 9, 3, 11, 2, -1], [9, 5, 7, 9, 7, 2, 2, 7, 11, 9, 2, 0, -1],
        [2, 3, 11, 0, 1, 8, 1, 5, 8, 5, 7, 8, -1], [11, 2, 1, 11, 1, 7, 7, 1, 5, -1],
        [9, 5, 4, 10, 1, 3, 10, 3, 11, -1], [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1],
        [5, 4, 0, 5, 0, 11, 11, 0, 3, 5, 11, 10, -1], [5, 4, 8, 5, 8, 10, 10, 8, 11, -1],
        [10, 6, 11, -1], [6, 11, 10, -1], [5, 4, 9, 10, 6, 11, -1],
        [0, 3, 8, 4, 9, 5, 11, 10, 6, -1], [0, 1, 5, 0, 5, 4, -1], [8, 5, 4, 8, 3, 5, 3, 1, 5, -1],
        [10, 6, 11, 1, 2, 9, 9, 2, 0, -1], [6, 11, 10, 4, 9, 5, 8, 3, 2, -1],
        [2, 3, 8, 2, 8, 10, 10, 8, 9, 10, 9, 5, 10, 5, 6, -1],
        [9, 5, 4, 10, 6, 2, 2, 6, 11, -1], [0, 1, 5, 0, 5, 4, -1], [8, 5, 4, 8, 3, 5, 3, 1, 5, -1],
        [10, 6, 11, 1, 2, 9, 9, 2, 0, -1], [6, 11, 10, 4, 9, 5, 8, 3, 2, -1],
        [2, 3, 8, 2, 8, 10, 10, 8, 9, 10, 9, 5, 10, 5, 6, -1],
        [9, 5, 4, 10, 6, 2, 2, 6, 11, -1], [8, 2, 3, 9, 2, 8, 10, 2, 9, 5, 10, 9, -1],
        [5, 4, 0, 5, 0, 10, 10, 0, 2, -1], [10, 6, 5, 3, 8, 2, 8, 10, 2, 8, 5, 10, -1],
        [0, 1, 5, 0, 5, 4, -1], [8, 5, 4, 8, 3, 5, 3, 1, 5, -1],
        [10, 6, 11, 1, 2, 9, 9, 2, 0, -1], [6, 11, 10, 4, 9, 5, 8, 3, 2, -1],
        [2, 3, 8, 2, 8, 10, 10, 8, 9, 10, 9, 5, 10, 5, 6, -1],
        [9, 5, 4, 10, 6, 2, 2, 6, 11, -1], [0, 1, 5, 0, 5, 4, -1],
        [8, 5, 4, 8, 3, 5, 3, 1, 5, -1], [10, 6, 11, 1, 2, 9, 9, 2, 0, -1],
        [6, 11, 10, 4, 9, 5, 8, 3, 2, -1],
        [2, 3, 8, 2, 8, 10, 10, 8, 9, 10, 9, 5, 10, 5, 6, -1],
        [9, 5, 4, 10, 6, 2, 2, 6, 11, -1], [4, 7, 8, 6, 11, 10, -1],
        [4, 3, 0, 7, 3, 4, 6, 11, 10, -1], [10, 6, 11, 1, 0, 9, 8, 4, 7, -1],
        [4, 7, 11, 9, 4, 11, 9, 11, 6, 9, 6, 1, -1], [6, 11, 10, 4, 7, 8, -1],
        [7, 3, 0, 7, 0, 4, 3, 7, 4, -1], [10, 6, 11, 0, 9, 1, 8, 4, 7, -1],
        [7, 11, 4, 11, 9, 4, 11, 1, 9, 11, 6, 1, -1], [3, 11, 6, 3, 6, 4, 4, 6, 10, 4, 10, 1, -1],
        [1, 4, 10, 4, 7, 10, 7, 8, 10, 8, 0, 10, -1], [10, 6, 11, 4, 7, 8, 0, 3, 9, -1],
        [7, 11, 4, 11, 9, 4, 11, 0, 9, 11, 6, 0, -1], [3, 11, 6, 3, 6, 0, 0, 6, 10, 0, 10, 1, -1],
        [1, 4, 10, 4, 7, 10, 7, 8, 10, 8, 0, 10, -1], [10, 6, 11, 4, 7, 8, 9, 5, 0, -1],
        [5, 4, 7, 5, 7, 10, 10, 7, 11, 5, 10, 6, -1], [8, 4, 7, 9, 5, 0, 10, 6, 11, -1],
        [5, 4, 7, 5, 7, 10, 10, 7, 11, 5, 10, 6, -1], [1, 2, 6, 1, 6, 5, 3, 11, 7, -1],
        [0, 8, 3, 2, 6, 5, 6, 1, 5, -1], [9, 5, 0, 8, 4, 7, 6, 2, 10, -1],
        [5, 1, 6, 1, 2, 6, 3, 11, 7, -1], [11, 7, 3, 6, 5, 9, 6, 9, 0, 6, 0, 2, -1],
        [7, 8, 4, 11, 3, 6, 3, 5, 6, 3, 1, 5, -1], [9, 5, 0, 8, 4, 7, 10, 6, 2, -1],
        [5, 6, 10, 5, 10, 7, 7, 10, 2, 7, 2, 3, -1], [4, 7, 8, 9, 5, 0, 10, 6, 2, -1],
        [5, 6, 10, 5, 10, 7, 7, 10, 2, 7, 2, 3, -1], [1, 2, 6, 1, 6, 5, 3, 11, 7, -1],
        [0, 8, 3, 2, 6, 5, 6, 1, 5, -1], [9, 5, 0, 8, 4, 7, 6, 2, 10, -1],
        [5, 1, 6, 1, 2, 6, 3, 11, 7, -1], [11, 7, 3, 6, 5, 9, 6, 9, 0, 6, 0, 2, -1],
        [7, 8, 4, 11, 3, 6, 3, 5, 6, 3, 1, 5, -1], [9, 5, 0, 8, 4, 7, 10, 6, 2, -1],
        [5, 6, 10, 5, 10, 7, 7, 10, 2, 7, 2, 3, -1], [4, 7, 8, 9, 5, 0, 10, 6, 2, -1],
        [5, 6, 10, 5, 10, 7, 7, 10, 2, 7, 2, 3, -1]
    ]

    edge_vertices = [
        (0, 1), (1, 2), (2, 3), (3, 0),
        (4, 5), (5, 6), (6, 7), (7, 4),
        (0, 4), (1, 5), (2, 6), (3, 7)
    ]

    grad = np.gradient

    def __init__(self, isolevel: float = 0.0):
        self.isolevel = isolevel

    def compute(self, sdf_grid: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
            """执行完整的移动立方体算法"""
            vertices = []
            faces = []
            nx, ny, nz = sdf_grid.shape

            # 预先计算梯度场（法线方向）
            grad_x, grad_y, grad_z = np.gradient(sdf_grid)
            normals = np.stack((-grad_x, -grad_y, -grad_z), axis=3)
            normals /= np.linalg.norm(normals, axis=3, keepdims=True) + 1e-8

            for x in range(nx - 1):
                for y in range(ny - 1):
                    for z in range(nz - 1):
                        # 获取当前立方体8个顶点的SDF值
                        cell_values = [
                            sdf_grid[x, y, z],
                            sdf_grid[x + 1, y, z],
                            sdf_grid[x + 1, y + 1, z],
                            sdf_grid[x, y + 1, z],
                            sdf_grid[x, y, z + 1],
                            sdf_grid[x + 1, y, z + 1],
                            sdf_grid[x + 1, y + 1, z + 1],
                            sdf_grid[x, y + 1, z + 1]
                        ]

                        # 计算立方体索引
                        cube_index = 0
                        for i in range(8):
                            if cell_values[i] < self.isolevel:
                                cube_index |= 1 << i

                        # 查找边配置
                        edges = MarchingCubes.edge_table[cube_index]
                        if edges == 0:
                            continue

                        # 计算边交点
                        vert_list = []
                        for i in range(12):
                            if edges & (1 << i):
                                v1, v2 = MarchingCubes.edge_vertices[i]

                                # 计算插值权重
                                val1 = cell_values[v1]
                                val2 = cell_values[v2]
                                mu = (self.isolevel - val1) / (val2 - val1 + 1e-8)

                                # 计算顶点坐标
                                if i == 0:
                                    pos = (x + mu, y, z)
                                elif i == 1:
                                    pos = (x + 1, y, z + mu)
                                elif i == 2:
                                    pos = (x + 1 - mu, y + 1, z)
                                elif i == 3:
                                    pos = (x, y + 1, z + mu)
                                elif i == 4:
                                    pos = (x + mu, y, z + 1)
                                elif i == 5:
                                    pos = (x + 1, y, z + 1 - mu)
                                elif i == 6:
                                    pos = (x + 1 - mu, y + 1, z + 1)
                                elif i == 7:
                                    pos = (x, y + 1, z + 1 - mu)
                                elif i == 8:
                                    pos = (x, y + mu, z)
                                elif i == 9:
                                    pos = (x + 1, y + mu, z)
                                elif i == 10:
                                    pos = (x + 1, y + mu, z + 1)
                                elif i == 11:
                                    pos = (x, y + mu, z + 1)

                                # 计算法线（基于梯度场插值）
                                n1 = normals[x if v1 in [0, 3, 7] else x + 1,
                                y if v1 in [0, 1, 5] else y + 1,
                                z if v1 in [0, 4, 7] else z + 1]
                                n2 = normals[x if v2 in [0, 3, 7] else x + 1,
                                y if v2 in [0, 1, 5] else y + 1,
                                z if v2 in [0, 4, 7] else z + 1]
                                normal = n1 * (1 - mu) + n2 * mu

                                vert_list.append((pos, normal))

                        # 生成三角形
                        i = 0
                        while True:
                            if MarchingCubes.tri_table[cube_index][i] == -1:
                                break

                            # 创建三角形
                            tri = []
                            for j in range(3):
                                edge_idx = MarchingCubes.tri_table[cube_index][i + j]
                                pos, normal = vert_list[edge_idx]

                                # 添加顶点（带法线）
                                vertex = (
                                    pos[0] / (nx - 1) * 2 - 1,  # 归一化到[-1,1]
                                    pos[1] / (ny - 1) * 2 - 1,
                                    pos[2] / (nz - 1) * 2 - 1,
                                    normal[0],
                                    normal[1],
                                    normal[2]
                                )

                                # 检查重复顶点
                                found = False
                                for v_idx, v in enumerate(vertices):
                                    if (abs(v[0] - vertex[0]) < 1e-5 and
                                            abs(v[1] - vertex[1]) < 1e-5 and
                                            abs(v[2] - vertex[2]) < 1e-5):
                                        tri.append(v_idx)
                                        found = True
                                        break
                                if not found:
                                    tri.append(len(vertices))
                                    vertices.append(vertex)

                            faces.append(tri)
                            i += 3

            # 转换为numpy数组
            vertices_array = np.array([v[:3] for v in vertices], dtype=np.float32)
            normals_array = np.array([v[3:] for v in vertices], dtype=np.float32)
            faces_array = np.array(faces, dtype=np.int32)

            return vertices_array, faces_array
